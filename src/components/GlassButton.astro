---
interface Props {
    href?: string;
    label: string;
    class?: string;
}

const { href = "#", label, class: className = "" } = Astro.props;
---

<a href={href} class:list={["glass-button", className]}>
    <span class="glass-button-inner"></span>
    <span class="glass-button-label">{label}</span>
</a>

<style>
    .glass-button {
        /* Configuración */
        --glass-radius: 9999px;
        --glass-bg: hsla(240, 8%, 68%, 0.082);

        /* Variables JS */
        --x: 50%;
        --y: 50%;
        --spotlight-opacity: 0;

        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        cursor: pointer;
        padding: 0.15rem 2.4rem;

        transform: translateZ(0);
        will-change: auto;
    }

    /* TEXTO */
    .glass-button-label {
        position: relative;
        z-index: 10;
        color: #101214;
        font-family: var(--font, system-ui, sans-serif);
        font-size: 20px;
        font-weight: 500;
        letter-spacing: 0.02em;
        pointer-events: none;
    }

    /* CRISTAL (Cuerpo) */
    .glass-button-inner {
        position: absolute;
        inset: 0;
        border-radius: var(--glass-radius);
        background-color: var(--glass-bg);

        backdrop-filter: blur(0.4rem) saturate(200%);
        -webkit-backdrop-filter: blur(0.4rem) saturate(200%);

        /* Sombra oscura sutil (como pediste) */
        box-shadow:
            inset 0 0 0.4rem 0.2rem rgba(16, 18, 20, 0.2),
            0 0.8rem 0.8rem rgba(84, 77, 86, 0.05);

        animation: jelly-shrink 0.6s ease forwards;
    }

    /* HOVER */
    .glass-button:hover .glass-button-inner {
        animation: smooth-expand 0.4s ease forwards;
        box-shadow:
            inset 0 0 0.4rem 0.2rem rgba(16, 18, 20, 0.1),
            0 0.8rem 0.8rem rgba(84, 77, 86, 0.1);
    }

    /* --- 3. BORDE REPULSIVO (Dinámico) --- */
    .glass-button-inner::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        padding: 0.5px; /* Más fino */
        pointer-events: none;

        /* Luz blanca suave que se mueve */
        background: radial-gradient(
            160px circle at var(--x) var(--y),
            rgba(255, 255, 255, 0.7) 0%,
            transparent 100%
        );

        /* Máscara */
        -webkit-mask:
            linear-gradient(#fff 0 0) content-box,
            linear-gradient(#fff 0 0);
        mask:
            linear-gradient(#fff 0 0) content-box,
            linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;

        opacity: var(--spotlight-opacity);
        transition: opacity 0.2s ease;
    }

    /* --- 4. BORDE ESTÁTICO (Fijo) --- */
    .glass-button-inner::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        padding: 0.65px; /* Más fino */
        pointer-events: none;

        /* Gradiente diagonal fijo sutil */
        background: linear-gradient(
            -45deg,
            rgba(255, 255, 255, 0.3) 0%,
            rgba(255, 255, 255, 0) 40%,
            rgba(255, 255, 255, 0) 60%,
            rgba(255, 255, 255, 0.3) 100%
        );

        -webkit-mask:
            linear-gradient(#fff 0 0) content-box,
            linear-gradient(#fff 0 0);
        mask:
            linear-gradient(#fff 0 0) content-box,
            linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;
    }

    /* Animaciones */
    @keyframes smooth-expand {
        0% {
            transform: perspective(200px) scale(1, 1) rotateX(0deg)
                translateZ(0);
        }
        50% {
            transform: perspective(200px) scale(1.04, 1.2) rotateX(3deg)
                translateZ(8px);
        }
        100% {
            transform: perspective(200px) scale(1.03, 1.15) rotateX(2deg)
                translateZ(5px);
        }
    }

    @keyframes jelly-shrink {
        0% {
            transform: scale(1.03, 1.15);
        }
        25% {
            transform: scale(1.05, 0.9);
        }
        50% {
            transform: scale(0.98, 1.05);
        }
        75% {
            transform: scale(1.01, 0.98);
        }
        100% {
            transform: scale(1, 1);
        }
    }
</style>

<script>
    function initRepulsionSpotlight() {
        const buttons = document.querySelectorAll(".glass-button");

        // A qué distancia (en px) empieza a reaccionar el borde
        const PROXIMITY_RADIUS = 1450;

        document.addEventListener("mousemove", (e) => {
            buttons.forEach((btn) => {
                const el = btn as HTMLElement;
                const rect = el.getBoundingClientRect();

                // Centros
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Distancia Mouse - Centro Botón
                const deltaX = e.clientX - centerX;
                const deltaY = e.clientY - centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // --- LÓGICA DE REPULSIÓN ---
                // Invertimos el delta: Si el mouse está a la izquierda (-x), la luz va a la derecha (+x)
                // localCenter es el 50% del botón
                const localCx = rect.width / 2;
                const localCy = rect.height / 2;

                // El factor 1.2 hace que la luz se mueva un poco más rápido que el mouse para "huir"
                const repulsionX = localCx - deltaX * 1.2;
                const repulsionY = localCy - deltaY * 1.2;

                el.style.setProperty("--x", `${repulsionX}px`);
                el.style.setProperty("--y", `${repulsionY}px`);

                // --- LÓGICA DE OPACIDAD POR PROXIMIDAD ---
                // Empezamos a contar la distancia desde el borde del botón, no desde el centro
                const distanceToEdge = Math.max(
                    0,
                    distance - Math.max(rect.width, rect.height) / 2,
                );

                if (distanceToEdge < PROXIMITY_RADIUS) {
                    // Mapear: 0 distancia = 1 opacidad / 250 distancia = 0 opacidad
                    const opacity = 1 - distanceToEdge / PROXIMITY_RADIUS;
                    // Curva exponencial para que aparezca suavemente
                    el.style.setProperty(
                        "--spotlight-opacity",
                        `${Math.pow(opacity, 1.5)}`,
                    );
                } else {
                    el.style.setProperty("--spotlight-opacity", "0");
                }
            });
        });
    }

    initRepulsionSpotlight();
    document.addEventListener("astro:page-load", initRepulsionSpotlight);
</script>
