---
import KatanaViewer from "../react/KatanaViewer";
---

<section id="katana-section" class="katana-section">
    <div class="katana-sticky">
        <!-- Espada: ocupa todo el espacio -->
        <div class="katana-viewer">
            <KatanaViewer client:only="react" />
        </div>

        <!-- Texto centrado sobre la espada: una palabra a la vez -->
        <div class="katana-text">
            <p class="text-word" data-word="0">Concentrate</p>
            <p class="text-word" data-word="1">Sharp</p>
            <p class="text-word" data-word="2">Efficient</p>
            <p class="text-word" data-word="3">Fast</p>
        </div>
    </div>
</section>

<style>
    .katana-section {
        width: 100%;
        height: 500vh;
    }

    .katana-sticky {
        position: sticky;
        top: 0;
        height: 100vh;
        width: 100%;
    }

    /* ========================================
       3D VIEWER — ocupa todo el espacio
       ======================================== */
    .katana-viewer {
        position: relative;
        z-index: 2;
        width: 100%;
        height: 100vh;
    }

    /* ========================================
       TEXTO — centrado sobre la espada
       ======================================== */
    .katana-text {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
        pointer-events: none;
    }

    .text-word {
        --reveal: 0;
        --hide: 0;
        position: absolute;
        color: var(--c-white);
        font-family: 'Cinzel', serif;
        font-size: var(--large);
        font-weight: 400;
        line-height: 1;
        letter-spacing: -0.03em;
        text-align: center;
        margin: 0;

        /*
         * Efecto humo: blur + opacity, sin movimiento vertical.
         *   reveal 0→1 = aparece
         *   hide   0→1 = desaparece
         */
        opacity: calc(var(--reveal) - var(--hide));
        filter: blur(calc((1 - var(--reveal) + var(--hide)) * 32px));
        will-change: filter, opacity;
    }

    /* ========================================
       MOBILE
       ======================================== */
    @media (max-width: 1024px) {
        .text-word {
            font-size: var(--h1);
        }
    }
</style>

<script>
    const section = document.getElementById('katana-section');
    const words = document.querySelectorAll('.text-word');

    /*
     * Timing por palabra (valores de progress 0→1 sobre los 300vh de scroll).
     * Cada palabra tiene: revealStart→revealEnd (aparece) y hideStart→hideEnd (desaparece).
     * "Fast" es la última y no tiene hide (se queda visible).
     */
    const TIMINGS = [
        { revealStart: 0.0,  revealEnd: 0.1,  hideStart: 0.15, hideEnd: 0.25 }, // Concentrate
        { revealStart: 0.25, revealEnd: 0.35, hideStart: 0.4,  hideEnd: 0.5  }, // Sharp
        { revealStart: 0.5,  revealEnd: 0.6,  hideStart: 0.65, hideEnd: 0.75 }, // Efficient
        { revealStart: 0.75, revealEnd: 0.85, hideStart: 0.9,  hideEnd: 1.0  }, // Fast — se desvanece al final
    ];

    function clamp01(v: number) { return Math.max(0, Math.min(1, v)); }

    function update() {
        if (!section) return;

        const rect = section.getBoundingClientRect();
        const scrollableRange = section.offsetHeight - window.innerHeight;

        if (scrollableRange <= 0) {
            requestAnimationFrame(update);
            return;
        }

        const progress = Math.max(0, Math.min(1, -rect.top / scrollableRange));

        words.forEach((word, i) => {
            const t = TIMINGS[i];
            if (!t) return;

            const reveal = clamp01((progress - t.revealStart) / (t.revealEnd - t.revealStart));
            const hide   = t.hideEnd > t.hideStart
                ? clamp01((progress - t.hideStart) / (t.hideEnd - t.hideStart))
                : 0;

            (word as HTMLElement).style.setProperty('--reveal', reveal.toFixed(3));
            (word as HTMLElement).style.setProperty('--hide',   hide.toFixed(3));
        });

        requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
</script>
