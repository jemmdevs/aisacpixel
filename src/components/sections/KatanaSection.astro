---
import KatanaViewer from "../react/KatanaViewer";
---

<section id="katana-section" class="katana-section">
    <div class="katana-sticky">
        <!-- Espada: ocupa todo el espacio -->
        <div class="katana-viewer">
            <KatanaViewer client:only="react" />
        </div>

        <!-- Textos en las 4 esquinas -->
        <div class="corner-texts">
            <span class="corner tl">Wide range of effects</span>
            <span class="corner tr">Effortless initialization</span>
            <span class="corner bl">Performance oriented</span>
            <span class="corner br">Attribute-Based Integration</span>
        </div>

        <!-- Texto centrado sobre la espada: una palabra a la vez -->
        <div class="katana-text">
            <p class="text-word" data-word="0">Concentrate</p>
            <p class="text-word" data-word="1">Sharp</p>
            <p class="text-word" data-word="2">Efficient</p>
            <p class="text-word" data-word="3">Fast</p>
        </div>
    </div>
</section>

<style>
    .katana-section {
        width: 100%;
        height: 500vh;
    }

    .katana-sticky {
        position: sticky;
        top: 0;
        height: 100vh;
        width: 100%;
    }

    /* ========================================
       3D VIEWER — ocupa todo el espacio
       ======================================== */
    .katana-viewer {
        position: relative;
        z-index: 2;
        width: 100%;
        height: 100vh;
    }

    /* ========================================
       TEXTO — centrado sobre la espada
       ======================================== */
    .katana-text {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
        pointer-events: none;
    }

    .text-word {
        --reveal: 0;
        --hide: 0;
        position: absolute;
        color: var(--c-white);
        font-family: 'Cinzel', serif;
        font-size: var(--large);
        font-weight: 400;
        line-height: 1;
        letter-spacing: -0.03em;
        text-align: center;
        margin: 0;

        /*
         * Efecto humo: blur + opacity, sin movimiento vertical.
         *   reveal 0→1 = aparece
         *   hide   0→1 = desaparece
         */
        opacity: calc(var(--reveal) - var(--hide));
        filter: blur(calc((1 - var(--reveal) + var(--hide)) * 32px));
        will-change: filter, opacity;
    }

    /* ========================================
       ESQUINAS
       ======================================== */
    .corner-texts {
        position: absolute;
        inset: 0;
        z-index: 3;
        pointer-events: none;
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        padding: var(--g-margin);
    }

    .corner {
        color: var(--c-white);
        font-family: var(--font);
        font-size: var(--h5);
        font-weight: 400;
        margin: 0;
        max-width: 14rem;
        line-height: 1.1;
    }

    .corner.tl { align-self: start; justify-self: start; margin-top: 4rem; }
    .corner.tr { align-self: start; justify-self: end;   text-align: right; margin-top: 4rem; }
    .corner.bl { align-self: end;   justify-self: start; margin-bottom: 1.5rem; }
    .corner.br { align-self: end;   justify-self: end;   text-align: right; margin-bottom: 1.5rem; }

    /* ========================================
       MOBILE
       ======================================== */
    @media (max-width: 1024px) {
        .text-word {
            font-size: var(--h1);
        }
    }
</style>

<script>
    const section = document.getElementById('katana-section');
    const words = document.querySelectorAll('.text-word');

    /*
     * Timing por palabra (valores de progress 0→1 sobre los 500vh de scroll).
     * Cada palabra tiene: revealStart→revealEnd (aparece) y hideStart→hideEnd (desaparece).
     */
    const TIMINGS = [
        { revealStart: 0.0,  revealEnd: 0.1,  hideStart: 0.15, hideEnd: 0.25 }, // Concentrate
        { revealStart: 0.25, revealEnd: 0.35, hideStart: 0.4,  hideEnd: 0.5  }, // Sharp
        { revealStart: 0.5,  revealEnd: 0.6,  hideStart: 0.65, hideEnd: 0.75 }, // Efficient
        { revealStart: 0.75, revealEnd: 0.85, hideStart: 0.9,  hideEnd: 1.0  }, // Fast
    ];

    function clamp01(v: number) { return Math.max(0, Math.min(1, v)); }

    function update() {
        if (!section) return;

        const rect = section.getBoundingClientRect();
        const scrollableRange = section.offsetHeight - window.innerHeight;
        if (scrollableRange <= 0) return;

        const progress = Math.max(0, Math.min(1, -rect.top / scrollableRange));

        words.forEach((word, i) => {
            const t = TIMINGS[i];
            if (!t) return;

            const reveal = clamp01((progress - t.revealStart) / (t.revealEnd - t.revealStart));
            const hide   = t.hideEnd > t.hideStart
                ? clamp01((progress - t.hideStart) / (t.hideEnd - t.hideStart))
                : 0;

            (word as HTMLElement).style.setProperty('--reveal', reveal.toFixed(3));
            (word as HTMLElement).style.setProperty('--hide',   hide.toFixed(3));
        });
    }

    // RAF loop que solo corre cuando la sección está en vista
    let rafId: number | null = null;

    function loop() {
        update();
        rafId = requestAnimationFrame(loop);
    }

    if (section) {
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                if (rafId === null) rafId = requestAnimationFrame(loop);
            } else {
                if (rafId !== null) { cancelAnimationFrame(rafId); rafId = null; }
            }
        }, { rootMargin: '100px' });

        observer.observe(section);
    }
</script>
